{"ast":null,"code":"var _jsxFileName = \"H:\\\\Proyecto\\\\react-wikishow\\\\src\\\\components\\\\hero-slide\\\\HeroSlide.jsx\",\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport React, { useState, useEffect, useRef } from 'react'; //Devuelve un valor con estado y una función para actualizarlo.\n//La función pasada a useEffect se ejecutará después de que el renderizado es confirmado en la pantalla.\n//En esencia, useRef es como una “caja” que puedes mantener en una variable mutable en su propiedad .current.\n\nimport { useHistory } from 'react-router';\nimport { Swiper, SwiperSlide } from 'swiper/react';\nimport ConfigApi, { category, movieType } from '../../api/ConfigApi';\nimport ImagesApi from '../../api/ImagesApi';\nimport Button from '../button/Button';\nimport Modal, { ModalContent } from '../modal/Modal';\nimport './hero-slide.scss';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst HeroSlide = () => {\n  _s2();\n\n  var _s = $RefreshSig$();\n\n  //Creamos los items de las peliculas es decir el conjunto y estableceremos que peliculas aparecera, con un estado vacio en ambos claro \n  const [movies, setMovieItems] = useState(['']);\n  /*Sincronizamos todas las peliculas , que pertenezcan a la primera pagina y haremos un try catch, donde esperamos la respuesta\n  de la API, con el tipo de Peliculas populares, que pertenezcan a la pagina 1, es decir params, ahora esa respuesta la volcaremos en\n  setMovieItems, y esa respuesta mediante el slice, la diviremos en 8 partes, es decir la cantidad de donde empieza y donde acaba*/\n\n  useEffect(() => {\n    const getMovies = async () => {\n      const params = {\n        page: 1\n      };\n      {\n        const response = await ConfigApi.getMoviesList(movieType.popular, {\n          params\n        });\n        setMovieItems(response.results.slice(0, 7));\n      }\n    };\n\n    getMovies();\n  }, []);\n  /*Crearemos el Video, cogiendo las propiedades de peliculas, el evento onClose, es muy imporante para cuando cierras\n  el trailer el video no se siga reproduciendo en un segundo plano*/\n\n  const Video = props => {\n    _s();\n\n    const film = props.film;\n    const iframe = useRef(\"\");\n\n    const close = () => iframe.current.setAttribute('src', '');\n\n    return /*#__PURE__*/_jsxDEV(Modal, {\n      id: `modal_${film.id}`,\n      children: /*#__PURE__*/_jsxDEV(ModalContent, {\n        onClose: close,\n        children: /*#__PURE__*/_jsxDEV(\"iframe\", {\n          ref: iframe,\n          width: \"100%\",\n          height: \"700px\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 51,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 49,\n      columnNumber: 13\n    }, this);\n  };\n  /*Vale ahora devolvemos un return del hero slide, llamamos a la clase como en html y ahora con la propiedades del SWIPPER\n  hacemos que coga el curso,importante la linea 67 hace que el propio cursos manteniendolo podramos moverlo, esto esta\n  pensado para movil pero para PC sirve igual, decimos que queremos ver unicamente un slide es decir de 1en1 si no se puede\n  quedar en la mitad del slice de las peliculas.\n  Ahora con las peliculas, haremos un mapeo para ir uno por uno,mostrando cada pelicula en cada swiper,\n  sin estas propiedades aparecera un swiper sin contenido alguno, por lo tanto es obligatorio mapear el slide*/\n\n\n  _s(Video, \"yeoAKYzwHGpzlfLaV/1uTwoJwfI=\");\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"hero-slide\",\n    children: [/*#__PURE__*/_jsxDEV(Swiper, {\n      slidesPerView: 1,\n      children: movies.map((film, index) => /*#__PURE__*/_jsxDEV(SwiperSlide, {\n        children: _ref => {\n          let {\n            isActive\n          } = _ref;\n          return /*#__PURE__*/_jsxDEV(HeroSlideItem, {\n            film: film,\n            className: `${isActive ? 'active' : ''}`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 72,\n            columnNumber: 33\n          }, this);\n        }\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 70,\n        columnNumber: 25\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 13\n    }, this), movies.map((film, index) => /*#__PURE__*/_jsxDEV(Video, {\n      film: film\n    }, index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 45\n    }, this))]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 64,\n    columnNumber: 9\n  }, this);\n};\n/*La linea 65 sirve para poder llegar a ver el trailer asociado a esa pelicula, por eso del Video modal,\n tiene que mapear cada pelicula con su trailer y lo hacemos mediante la key */\n\n\n_s2(HeroSlide, \"RjQZDmoHCMqB2+vJOylnkk9aeFQ=\");\n\n_c = HeroSlide;\n\nconst HeroSlideItem = props => {\n  _s3();\n\n  //El enlace useHistory nos permite acceder al objeto de historial de React Router.\n  let history = useHistory(); //Volcamos las propiedades de las peliculas en film, y configuramos el background con las propiedades de la API, como el poster\n  //Si no encuentra el backdrop, cogera el poster es decir siempre tendra un fondo \n\n  const film = props.film;\n  const background = ImagesApi.original(film.backdrop_path ? film.backdrop_path : film.poster_path); //El componente modal proporciona una base sólida para crear cuadros de diálogo, popovers, lightboxes o cualquier otra cosa.\n\n  const setModalSelected = async () => {\n    const modal = document.querySelector(`#modal_${film.id}`);\n    const trailer = await ConfigApi.getVideos(category.movie, film.id); //Decimos que si tiene algun trailer,cojeremos la url del video, y cogeremos el primer resultado,\n    //Normalmente el resultado 0, suele ser el trailer pero no es 100% seguro y eso lo volcamos al iframe\n\n    if (trailer.results.length > 0) {\n      const video = 'https://www.youtube.com/embed/' + trailer.results[1].key;\n      modal.querySelector('.modal__content > iframe').setAttribute('src', video);\n    }\n\n    modal.classList.toggle('active'); //Con esto aparecera el iframe con el trailer\n  };\n  /*Aqui devolveremos el html con todos los componentes anteriormente creados, llamaremos a film que tiene todas las propiedades\n  titulo overview, poster e incluso un fondo y los btn de Boton.jsx y la configuracion de la API es decir todo se junta aqui*/\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `hero-slide__item ${props.className}`,\n    style: {\n      backgroundImage: `url(${background})`\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"hero-slide__item__content container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"hero-slide__item__content__info\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          className: \"title\",\n          children: film.title\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 124,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"overview\",\n          children: film.overview\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 125,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"btns\",\n          children: [/*#__PURE__*/_jsxDEV(Button, {\n            onClick: () => history.push('/movie/' + film.id),\n            children: \"Watch now\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 127,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(Button, {\n            onClick: setModalSelected,\n            children: \"Watch video\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 130,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 123,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"hero-slide__item__content__poster\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: ImagesApi.original(film.poster_path),\n          alt: \"\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 136,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 135,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 118,\n    columnNumber: 9\n  }, this);\n};\n\n_s3(HeroSlideItem, \"9cZfZ04734qoCGIctmKX7+sX6eU=\", false, function () {\n  return [useHistory];\n});\n\n_c2 = HeroSlideItem;\nexport default HeroSlide;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"HeroSlide\");\n$RefreshReg$(_c2, \"HeroSlideItem\");","map":{"version":3,"sources":["H:/Proyecto/react-wikishow/src/components/hero-slide/HeroSlide.jsx"],"names":["React","useState","useEffect","useRef","useHistory","Swiper","SwiperSlide","ConfigApi","category","movieType","ImagesApi","Button","Modal","ModalContent","HeroSlide","movies","setMovieItems","getMovies","params","page","response","getMoviesList","popular","results","slice","Video","props","film","iframe","close","current","setAttribute","id","map","index","isActive","HeroSlideItem","history","background","original","backdrop_path","poster_path","setModalSelected","modal","document","querySelector","trailer","getVideos","movie","length","video","key","classList","toggle","className","backgroundImage","title","overview","push"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\n//Devuelve un valor con estado y una función para actualizarlo.\n//La función pasada a useEffect se ejecutará después de que el renderizado es confirmado en la pantalla.\n//En esencia, useRef es como una “caja” que puedes mantener en una variable mutable en su propiedad .current.\n\nimport { useHistory } from 'react-router';\nimport { Swiper, SwiperSlide } from 'swiper/react';\n\nimport ConfigApi, { category, movieType } from '../../api/ConfigApi';\nimport ImagesApi from '../../api/ImagesApi';\n\nimport Button from '../button/Button';\nimport Modal, { ModalContent } from '../modal/Modal';\n\n\nimport './hero-slide.scss';\n\n\nconst HeroSlide = () => {\n\n    //Creamos los items de las peliculas es decir el conjunto y estableceremos que peliculas aparecera, con un estado vacio en ambos claro \n    const [movies, setMovieItems] = useState(['']);\n\n    /*Sincronizamos todas las peliculas , que pertenezcan a la primera pagina y haremos un try catch, donde esperamos la respuesta\n    de la API, con el tipo de Peliculas populares, que pertenezcan a la pagina 1, es decir params, ahora esa respuesta la volcaremos en\n    setMovieItems, y esa respuesta mediante el slice, la diviremos en 8 partes, es decir la cantidad de donde empieza y donde acaba*/\n    useEffect(() => {\n        const getMovies = async () => {\n            const params = { page: 1 }\n            {\n                const response = await ConfigApi.getMoviesList(movieType.popular, { params });\n                setMovieItems(response.results.slice(0, 7));\n            }\n        }\n        getMovies();\n    }, []);\n\n    /*Crearemos el Video, cogiendo las propiedades de peliculas, el evento onClose, es muy imporante para cuando cierras\n    el trailer el video no se siga reproduciendo en un segundo plano*/\n    const Video = props => {\n\n        const film = props.film;\n\n        const iframe = useRef(\"\");\n\n        const close = () => iframe.current.setAttribute('src', '');\n\n        return (\n            <Modal id={`modal_${film.id}`}>\n                <ModalContent onClose={close}>\n                    <iframe ref={iframe} width=\"100%\" height=\"700px\"/>\n                </ModalContent>\n            </Modal>\n        )\n    }\n\n    /*Vale ahora devolvemos un return del hero slide, llamamos a la clase como en html y ahora con la propiedades del SWIPPER\nhacemos que coga el curso,importante la linea 67 hace que el propio cursos manteniendolo podramos moverlo, esto esta\npensado para movil pero para PC sirve igual, decimos que queremos ver unicamente un slide es decir de 1en1 si no se puede\nquedar en la mitad del slice de las peliculas.\nAhora con las peliculas, haremos un mapeo para ir uno por uno,mostrando cada pelicula en cada swiper,\nsin estas propiedades aparecera un swiper sin contenido alguno, por lo tanto es obligatorio mapear el slide*/\n    return (\n        <div className=\"hero-slide\">\n            <Swiper\n                slidesPerView={1}>\n\n                {\n                    movies.map((film, index) => (\n                        <SwiperSlide key={index}>\n                            {({ isActive }) => (\n                                <HeroSlideItem film={film} className={`${isActive ? 'active' : ''}`} />\n                            )}\n                        </SwiperSlide>\n                    ))\n                }\n            </Swiper>\n            {\n                movies.map((film, index) => <Video key={index} film={film} />)\n            }\n        </div>\n    );\n}\n/*La linea 65 sirve para poder llegar a ver el trailer asociado a esa pelicula, por eso del Video modal,\n tiene que mapear cada pelicula con su trailer y lo hacemos mediante la key */\n\nconst HeroSlideItem = props => {\n\n    //El enlace useHistory nos permite acceder al objeto de historial de React Router.\n    let history = useHistory();\n\n    //Volcamos las propiedades de las peliculas en film, y configuramos el background con las propiedades de la API, como el poster\n    //Si no encuentra el backdrop, cogera el poster es decir siempre tendra un fondo \n    const film = props.film;\n\n    const background = ImagesApi.original(film.backdrop_path ? film.backdrop_path : film.poster_path);\n\n    //El componente modal proporciona una base sólida para crear cuadros de diálogo, popovers, lightboxes o cualquier otra cosa.\n    const setModalSelected = async () => {\n        const modal = document.querySelector(`#modal_${film.id}`);\n\n        const trailer = await ConfigApi.getVideos(category.movie, film.id);\n\n        //Decimos que si tiene algun trailer,cojeremos la url del video, y cogeremos el primer resultado,\n        //Normalmente el resultado 0, suele ser el trailer pero no es 100% seguro y eso lo volcamos al iframe\n        if (trailer.results.length > 0) {\n            const video = 'https://www.youtube.com/embed/' + trailer.results[1].key;\n            modal.querySelector('.modal__content > iframe').setAttribute('src', video);\n        }\n\n        modal.classList.toggle('active'); //Con esto aparecera el iframe con el trailer\n    }\n\n    /*Aqui devolveremos el html con todos los componentes anteriormente creados, llamaremos a film que tiene todas las propiedades\n    titulo overview, poster e incluso un fondo y los btn de Boton.jsx y la configuracion de la API es decir todo se junta aqui*/\n\n    return (\n        <div\n            className={`hero-slide__item ${props.className}`}\n            style={{ backgroundImage: `url(${background})` }}\n        >\n            <div className=\"hero-slide__item__content container\">\n                <div className=\"hero-slide__item__content__info\">\n                    <h2 className=\"title\">{film.title}</h2>\n                    <div className=\"overview\">{film.overview}</div>\n                    <div className=\"btns\">\n                        <Button onClick={() => history.push('/movie/' + film.id)}>\n                            Watch now\n                        </Button>\n                        <Button onClick={setModalSelected}>\n                            Watch video\n                        </Button>\n                    </div>\n                </div>\n                <div className=\"hero-slide__item__content__poster\">\n                    <img src={ImagesApi.original(film.poster_path)} alt=\"\" />\n                </div>\n            </div>\n        </div>\n    )\n}\n\n\n\nexport default HeroSlide;\n"]},"metadata":{},"sourceType":"module"}